#!/bin/bash
set -e

# copilot-container - Run GitHub Copilot CLI in a sandboxed container
# 
# Usage:
#   copilot-container --mount /path/to/project [--yolo]
#   copilot-container --mount-overlay /path/to/project [--yolo]
#   copilot-container --clone owner/repo [--yolo]
#   copilot-container --show-changes
#   copilot-container --apply-changes

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
IMAGE_NAME="copilot-cli-container"
CONTAINER_NAME="copilot-cli-$$"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Detect container runtime
detect_runtime() {
    if command -v docker &> /dev/null; then
        echo "docker"
    elif command -v podman &> /dev/null; then
        echo "podman"
    else
        log_error "Neither docker nor podman found. Please install one."
        exit 1
    fi
}

show_help() {
    cat << 'EOF'
copilot-container - Run GitHub Copilot CLI in a sandboxed container

USAGE:
    copilot-container [OPTIONS]

OPTIONS:
    --mount <path>          Mount local directory (read-write, direct changes)
    --mount-overlay <path>  Mount with OverlayFS (changes isolated until applied)
    --clone <owner/repo>    Clone fresh from GitHub
    --yolo                  Enable auto-accept mode in Copilot CLI
    --show-changes          Show changes made in overlay mode
    --apply-changes         Apply overlay changes to original files
    --build                 Build/rebuild the container image
    --shell                 Start a shell instead of Copilot CLI
    -h, --help              Show this help message

EXAMPLES:
    # Work on a local project (direct changes)
    copilot-container --mount ~/my-project

    # Work safely with overlay (review changes before applying)
    copilot-container --mount-overlay ~/my-project --yolo
    copilot-container --show-changes
    copilot-container --apply-changes

    # Clone and work on a fresh repo
    copilot-container --clone facebook/react

ENVIRONMENT:
    GH_TOKEN or GITHUB_TOKEN - GitHub token for Copilot authentication

EOF
}

build_image() {
    local runtime=$(detect_runtime)
    log_info "Building container image with $runtime..."
    cd "$SCRIPT_DIR"
    $runtime build -t "$IMAGE_NAME" .
    log_info "Image built successfully: $IMAGE_NAME"
}

run_container() {
    local runtime=$(detect_runtime)
    local mode="$1"
    local path="$2"
    local extra_args=("${@:3}")
    
    # Base docker/podman run arguments
    local run_args=(
        --rm
        -it
        --name "$CONTAINER_NAME"
        --hostname copilot-container
    )
    
    # Pass GitHub token
    if [ -n "$GH_TOKEN" ]; then
        run_args+=(-e "GH_TOKEN=$GH_TOKEN")
    elif [ -n "$GITHUB_TOKEN" ]; then
        run_args+=(-e "GITHUB_TOKEN=$GITHUB_TOKEN")
    fi
    
    # Handle different modes
    case "$mode" in
        mount)
            local abs_path=$(cd "$path" && pwd)
            run_args+=(-v "$abs_path:/workspace")
            ;;
        mount-overlay)
            local abs_path=$(cd "$path" && pwd)
            run_args+=(
                -v "$abs_path:/workspace-base:ro"
                -e "COPILOT_OVERLAY_MODE=true"
                --cap-add=SYS_ADMIN
                --device /dev/fuse
            )
            ;;
        clone)
            run_args+=(-e "COPILOT_CLONE_REPO=$path")
            ;;
    esac
    
    # Add security restrictions
    run_args+=(
        --security-opt no-new-privileges
        --read-only
        --tmpfs /tmp
        --tmpfs /home/copilot:exec,mode=1777
    )
    
    # Allow writing to workspace directories
    if [ "$mode" = "mount-overlay" ]; then
        run_args+=(
            --tmpfs /workspace-changes:uid=1000,gid=1000
            --tmpfs /workspace-work:uid=1000,gid=1000
            --tmpfs /workspace:uid=1000,gid=1000
        )
    fi
    
    # Run the container
    log_info "Starting Copilot CLI container ($mode mode)..."
    $runtime run "${run_args[@]}" "$IMAGE_NAME" "${extra_args[@]}"
}

# Parse arguments
MODE=""
PATH_ARG=""
COPILOT_ARGS=()
SHELL_MODE=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --mount)
            MODE="mount"
            PATH_ARG="$2"
            shift 2
            ;;
        --mount-overlay)
            MODE="mount-overlay"
            PATH_ARG="$2"
            shift 2
            ;;
        --clone)
            MODE="clone"
            PATH_ARG="$2"
            shift 2
            ;;
        --yolo)
            COPILOT_ARGS+=("--yolo")
            shift
            ;;
        --show-changes)
            log_info "Showing changes from last overlay session..."
            # TODO: Implement persistent storage for overlay changes
            log_error "This feature requires a running overlay container or persistent storage."
            exit 1
            ;;
        --apply-changes)
            log_info "Applying changes from last overlay session..."
            # TODO: Implement persistent storage for overlay changes
            log_error "This feature requires a running overlay container or persistent storage."
            exit 1
            ;;
        --build)
            build_image
            exit 0
            ;;
        --shell)
            SHELL_MODE=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
done

# Validate arguments
if [ -z "$MODE" ]; then
    log_error "No mode specified. Use --mount, --mount-overlay, or --clone."
    echo ""
    show_help
    exit 1
fi

# Validate path exists for mount modes
if [[ "$MODE" == "mount" || "$MODE" == "mount-overlay" ]]; then
    if [ ! -d "$PATH_ARG" ]; then
        log_error "Directory does not exist: $PATH_ARG"
        exit 1
    fi
fi

# Check if image exists, build if not
runtime=$(detect_runtime)
if ! $runtime image inspect "$IMAGE_NAME" &> /dev/null; then
    log_warn "Image not found. Building..."
    build_image
fi

# Determine what to run
if [ "$SHELL_MODE" = true ]; then
    run_container "$MODE" "$PATH_ARG" /bin/bash
else
    run_container "$MODE" "$PATH_ARG" copilot "${COPILOT_ARGS[@]}"
fi
